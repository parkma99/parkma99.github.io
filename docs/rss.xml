<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Park Ma's Blog</title><link>parkma99.github.io</link><description>write something</description><copyright>Park Ma's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.com/parkma99/parkma99.github.io/assets/84610851/cbdd1097-0277-45bc-94d8-b3de96b53607</url><title>avatar</title><link>parkma99.github.io</link></image><lastBuildDate>Sat, 02 Dec 2023 17:33:02 +0000</lastBuildDate><managingEditor>Park Ma's Blog</managingEditor><pubDate>Sat, 02 Dec 2023 17:33:02 +0000</pubDate><ttl>60</ttl><webMaster>Park Ma's Blog</webMaster><item><title>使用 LevelDB</title><link>parkma99.github.io/post/shi-yong-%20LevelDB.html</link><description>LevelDB是一个键值对数据库，是一个持久化的有序的Map。</description><guid isPermaLink="true">parkma99.github.io/post/shi-yong-%20LevelDB.html</guid><pubDate>Sat, 02 Dec 2023 17:27:45 +0000</pubDate></item><item><title>理解 Bloom filter 的工作原理</title><link>parkma99.github.io/post/li-jie-%20Bloom%20filter%20-de-gong-zuo-yuan-li.html</link><description>## 布隆过滤器的作用&#13;
&#13;
我们经常能遇到判断一个元素是否在一个给定的集合中的需求，使用哈希表就可以解决这个需求，并且查询的时间复杂度是常数级。</description><guid isPermaLink="true">parkma99.github.io/post/li-jie-%20Bloom%20filter%20-de-gong-zuo-yuan-li.html</guid><pubDate>Sat, 02 Dec 2023 12:25:10 +0000</pubDate></item><item><title>理解 LSM Tree 的工作原理</title><link>parkma99.github.io/post/li-jie-%20LSM%20Tree%20-de-gong-zuo-yuan-li.html</link><description>LSM 树是处理大量写入工作负载时通常使用的数据结构，通过仅执行顺序写入来优化写入路径。</description><guid isPermaLink="true">parkma99.github.io/post/li-jie-%20LSM%20Tree%20-de-gong-zuo-yuan-li.html</guid><pubDate>Sat, 02 Dec 2023 11:08:38 +0000</pubDate></item><item><title>spdlog 源码阅读 registry 类</title><link>parkma99.github.io/post/spdlog%20-yuan-ma-yue-du-%20registry%20-lei.html</link><description>## 从` spdlog::info("Welcome to spdlog!");` 开始阅读&#13;
&#13;
通过查找 ` spdlog::info` 函数定义，可以找到其定义在 `spdlog.h` 下&#13;
&#13;
```cpp&#13;
template&lt;typename... Args&gt;&#13;
inline void info(format_string_t&lt;Args...&gt; fmt, Args &amp;&amp;...args)&#13;
{&#13;
    default_logger_raw()-&gt;info(fmt, std::forward&lt;Args&gt;(args)...);&#13;
}&#13;
```&#13;
&#13;
其中使用了 ` default_logger_raw()` 应该是获取到了系统默认的记录日志的对象，然后调用这个对象的info 方法， 函数的参数是模版类型，以后在进行分析。</description><guid isPermaLink="true">parkma99.github.io/post/spdlog%20-yuan-ma-yue-du-%20registry%20-lei.html</guid><pubDate>Sat, 02 Dec 2023 09:39:37 +0000</pubDate></item><item><title>使用 spdlog 打日志 </title><link>parkma99.github.io/post/shi-yong-%20spdlog%20-da-ri-zhi-%20.html</link><description>## spdlog 是什么&#13;
&#13;
&gt; [spdlog](https://github.com/gabime/spdlog) Very fast, header-only/compiled, C++ logging library&#13;
&#13;
官方仓库介绍是可以只包含头文件的日志库， 具体使用下来可以只包含头文件，（由于本人的Cmake 的知识太少），使用头文件的方式必须指定在 include 目录下， 后面就将整个 spdlog 仓库作为第三方库放在third_party 下。</description><guid isPermaLink="true">parkma99.github.io/post/shi-yong-%20spdlog%20-da-ri-zhi-%20.html</guid><pubDate>Sat, 02 Dec 2023 04:21:13 +0000</pubDate></item><item><title>关于</title><link>parkma99.github.io/post/guan-yu.html</link><description>一个终身学习者。</description><guid isPermaLink="true">parkma99.github.io/post/guan-yu.html</guid><pubDate>Fri, 01 Dec 2023 12:51:20 +0000</pubDate></item></channel></rss>